# 为什么

## 故事
  一名Windows程序员，工作了三十年之久，退休了，Windows也一起被淘汰了，
      他的孙子这样问他：“爷爷，你以前是做什么工作的？”， 
      爷爷很自豪的说：“爷爷以前是做Windows程序员的，数以千万计的电脑在运行我写的程序。”， 
      他的孙子只是很轻描淡写的说了一句：“那个被淘汰的系统？”
  
## OS 历史
  从第一台IBM PC, 以及 Microsoft最开始的DOS, 到后来的Window 3.x, Windows 95, Windows XP(最经典)，以及Windows 10, 会发现一个有意思的事情，DOS时代的程序，很多不能在最新的Windows 10上跑。 就连XP上，很多人都喜欢的红警也不能在Windows 10上跑，会有很多限制。
  再说Mac系列，有MacBook Pro用的系统，有Iphone, Ipad的系统， 每个系统还不太一样，很多很老的Mac程序，在新版本上的Mac OS上是无法运行的。
  再说手机桌面，Sybian, Andriod，Andriod 直接淘汰了Sybian,曾经Nokia多么的辉煌，一代程序员的集体回忆，随着Sybian的凋零，一代人写的程序，彻底离开了历史舞台。而其中有多少很优秀的作品，就这样消失了。
  Unix的世界也是同样如此，曾经从UNIX V6,V7开始发迹，到后来的，BSD 4.3（经典版本）， 开始出现了分裂，有了AIX, HP UX, FreeBSD, Solaris, Linux等分支。软件世界开始互相不兼容，和传统的工业世界完全不一样。
  以及最近很新的AliOS, AliThings, RT-Thread, HelenOS， 都在新出一个系统，而且和很多老系统一样，都表现出来了，不兼容。
  不过也有几个例外，就是WIND的VxWorks系列的os, 他们可以做到向后兼容，数十年，都在兼容老版本。
  
## 软件工程的问题
  以上只是OS领域的问题，其他软件领域，也是类似。
  这看起来，锅不应该只是OS领域的，这应该是个更广义上的问题，软件工程的问题。
  坐看传统工程，比如：汽车的配件，都是有很多标准的。螺丝都是有从大到小的标准，软件行业就是没有这样的标准。
  软件行业的标准，似乎没有传统行业那么多，因为是新发展起来的，目前看到做得比较好的，就是RFC标准，以及POSIX 标准。
  其他并不是太好，如果软件行业能像传统工业，把标准做得更细，到螺丝级别，我相信，很多软件会更好用，就像VxWorks做到的那样，推广到全行业去。
  
## 大问题
  以前的程序员，都是英雄主义，一个人几天搞定一个Great Software, 典型的就像Bill Joy,当年只花了一个周末写了vi, 相信代码不会超过5000行，而现在，都是讲求团队作战，为什么？因为现在软件过于庞大，而且很复杂，现在的软件规模比其他领域，可能会复杂很多倍。比如：当去做一个Linux内核程序员的时候，恭喜你，要面对5000万行内核代码，一个人一天平均可以写100行代码，想想那么多代码，现实的打击是多大，本来想在Linux内核里做个高手的，看到5000万行代码，还是算了吧，做个小兵，都可能办不到。
  所以，以前面对的是千行级别的代码，现在是百万行的代码。但是为什么会产生这样的转变？
 
## 终极一问
  为什么软件规模从千行变成了几千万行？而且复杂度也跟着一起上来了，需要大量的人力来做这件事情，当人手不够怎么办？这是大部分的软件开发团队，逃不掉的问题。
  也是当前软件行业普遍存在的一个问题。
  这个问题的衍化的最后，就会迅速的，变成一个词：办不到。程序员，经常这样反驳别人：你提的需求有问题，这个功能做不到。这个功能要改的代码太多。
  而且，还有一个恶魔跟随着我们，我们也无处躲避，就是Bug, 有人统计，平均千行代码会有10个Bug, Linux Kernel 5000万行代码，可能会有15万个Bug, 这只是保守估计，软件越大，Bug越多，想起 ORACLE DB 的程序员的段子了，程序员接到一个BUG,花了两周的时间，看懂BUG相关代码，然后又花了两周的时候，加上一些神奇的Flag 再花上2月的时间，跑完几千个case, 没有问题，就发布一个BUG修复版本。好长的时间，解BUG,加FLAG.
  
## 庖丁解牛
  问题
  1. 从几千行到几千万行
  2. 复杂度上升
  3. Bug 增多
  4. 软件无法复用，直接淘汰
  
  解法
  第一个问题： 无法避免，一个飞船的所有系统的代码，必然是会很多的。而一个hello world. 相信只会有几行。
  第三个问题： 这个问题和第二个问题一起衍化，从经验来看，越复杂的代码，看不懂的人越多，不想看的人也越多，被放弃的概率越大，出现的BUG也越多。而越简单的代码，能看懂的人多，想看的人也多，出BUG的概率也小。
  第二个问题： 这是问题的核心，而且是一个老生常谈的问题，软件工程的解决方案也很多，我觉得最重要的就是模块化，标准化。这样就算出现5000万行代码，每个模块接口定义清晰，每个子系统，都互相隔离，看起来有5000万行代码，实际需要处理的就是5000行代码，我相信，会简单很多很多。
  第四个问题： 这是OS和软件本身设计的失误，一个可执行程序，不能被别的可执行程序，直接包含，或者不愿意被包含，没有形成这样的环境，如果一个程序由众多的模块组成，然后，它也可以直接被别的程序使用，我相信，就不会那么快的被淘汰，即使这个程序退出了，它曾经写过的公共模块，还是会留下来，继续会后续的程序服务。或者，它自身也会嵌入在很多进程里。简而言之就是UNIX的哲学KISS法则。模块化组成的程序，又拼成了模块化的程序。

## 备注
  困扰多年的心结，算是一个小段落结束了，希望激励看到文章的你，文章可能有很多错误，因为言多必失，有不当之处，欢迎指出。
  也许我们老了，下一代再问我们做什么的时候，希望我们写过的那个软件还在吧,不被当成一个无用的老头存在。
  
 
